\documentclass[12pt] {article}
\usepackage[top=1.75in, bottom=1.75in, left=1.75in, right=1.75in]{geometry}
\usepackage[pdftex]{hyperref}
\hypersetup{
	pdfauthor={Phil Monroe},
	pdftitle={The Low Down on Graphics Pipelines},
	colorlinks}
	
	
\begin{document}

\title{The Low Down on Graphics Pipelines}
\author{Phil Monroe}
\date{Jan. 17, 2011}
% \maketitle

\centerline{
	\Large \bf The Low Down on Graphics Pipelines} %% Paper title

% \medskip

\centerline{\bf Phil Monroe}
% \medskip

\centerline{Jan. 17, 2011}

\bigskip

% Intro ----------------------------------------------------------------------
Graphic processing units (GPUs) are becoming increasingly more important in modern computing. Largely driven by video games, today's computer software  demands higher performance and stunning visuals from GPUs. GPUs start out with several different objects and combine them to form an image in a series of stages called the graphics pipeline. For the sake of this article, think of an image where there is a soccer ball sitting on a table inside of a room. This article describes how this scene can be created on computer by going through all the stages of the GPU pipeline.

% Application ----------------------------------------------------------------
The graphics pipeline begins with the \emph{application} stage where running software interacts with the GPU. This first step of this stage is to build 3 dimensional models of each object that will be present in the scene. In the case of our soccer ball scene, the soccer ball, table and the room itself are each modeled independently, which are called objects. The 3D models of each of the objects are created using a mesh of triangles. To help visualize this mesh, consider the soccer ball. Real soccer balls are patches of hexagons and pentagons sewn together to form a round ball. So why use triangles instead of hexagons and pentagons to create the ball? Well it turns out that complex geometries, such as the hexagons and pentagons, can be broken down into triangles and triangles have nice mathematical properties that allow future stages to be simplified. Each triangle is defined by the three points that connect the sides, which are know as the vertices. To make these meshes of triangles more realistic looking, textures, which are images that seem to surround the 3D model like wrapping paper, are created and will be applied in later stages.

So now that we have a mesh of triangles to define the shape of our soccer ball, it is important to note that this 3D model is in it's own coordinate space called model space. This means that each model of an object contains absolutely no information about any of the other objects or how they relate spatially. Our soccer ball is floating in it's own universe where the only thing that exists is the soccer ball. Now the application needs to start transferring all of these models to the GPU to assemble into a scene. Along with the models, the application passes information on how the models should relate spatially, the textures they have, where the lights are and at what direction the user is looking at the models.

% Geometry -------------------------------------------------------------------
Now that the GPU knows about all of the objects that will be present, it can start piecing together the scene in what is called the \emph{geometry} stage. The first step in the geometry stage is to combine all of the models into a common world. This is done by using mathematical transformations to convert the objects from model space into what is called world space. All of the objects are now in the same universe and spaced properly. <LIGHTING>

It is now time to consider the viewpoint of the user, which is called the camera. Much like a camera in real life, we position the camera in the scene to determine what will be visible to the user. At this point, the GPU can start trimming away triangles that outside the rectangular edge of the camera's viewing area in a process called clipping. Clipping also remove rear facing triangles such as the triangles on the non-visible side of the soccer ball. The GPU removes these triangles to reduce the amount of processing that will be required in future steps.

Now we need to start making the scene two dimensional. This is accomplished by taking each object and projecting the 3D mesh of visible triangles onto a 2D plane. You then left with a bunch of 2D object at various distances, or depth, away from the camera. Visualize this as if we were creating a cartoon out of construction paper. We would first create each of the characters and object in a certain frame and then lay them on top of each other to form a scene. 


% Rasterization --------------------------------------------------------------
Let's take a moment to step away from the scene we are creating and consider the output medium that it will be displayed on, the screen. Electronic screens are two dimensional grids of colored dots called pixels. Think of them as sheets of graph paper and to draw an image you can only color in the individual squares. If the squares are large, the image looks very blocky and non distinct. However, if you shrink the size of the squares you get more detail into the image. So screens today pack a couple million tiny pixels close together to draw images with very high detail. So getting back to our scene, how are we going convert layers of 2D triangles into a bunch of pixels? This conversion process is call \emph{rasterization} and is the next stage of our graphics pipeline.

The rasterization process is similar to taking all of the 2D objects in our scene, laying them out on a sheet of graph paper representing the screen, and if the area of the object covers the center of a square on the graphing paper, then the square is considered part of the rasterized object. Each little square within the chunky rasterized object is called a fragment and contains all of the information, such as color and opacity, needed to draw that square to the corresponding pixel on the screen. At the end of the rasterization process, every object in the scene will converted into blocky rasterized objects at varying depths.

% Texture --------------------------------------------------------------------
Immediately following rasterization, the \emph{texture} stage is applied to the rasterized objects to make them appear more realistic. As hinted to earlier, textures are images that are wrapped around objects to provide a skin. While that is a convenient way of thinking of textures, that is not completely accurate. Textures are 2D images that show all sides of an object. Consider a real soccer ball with scuffs and grass stains that we want to show up on our digital soccer ball. A texture would be created that appears if the ball was cut up and laid flat in one piece. The pixels in the texture can now be overlaid onto the rasterized object to give more realistic coloring. During this process, some mathematical trickery is used to warp the texture to add perspective to the object and make it appear visually 3D.

% Composite ------------------------------------------------------------------
Now that all of our objects are in the rasterized and textured to look realistic, we need to combine the layers in a process known as the \emph{composition} stage. During composition, the fragments that make up the rasterized objects are combined to form one solid image. The GPU uses a structure called the frame buffer to hold all of the final pixels to be displayed on the screen. One by one, each object's fragments are copied over to the frame buffer. If two fragments collide in the same position in the frame buffer, then the fragment corresponding to an object closer to the camera will win. For transparent objects, the fragments are added together to allow distant objects to come through.


% Display --------------------------------------------------------------------
To display the final image, the frame buffer is read from beginning to end and sends the individual pixels to the screen. Each pixel is updated on the screen by starting with the top left corner and moving down to the bottom right corner. The GPU then repeats the whole process over to display the next image. For movies and movements within a world, the entire pipeline is run multiple times per second to create the illusion of continuous movement.


% References  ----------------------------------------------------------------
\clearpage
\subsection{References}

\url{	http://en.wikipedia.org/wiki/Graphics_pipeline}

\url{http://www.ericsink.com/wpf3d/5_Triangles.html}

\url{http://www.arcsynthesis.org/gltut/Basics/Intro%20Graphics%20and%20Rendering.html}

\url{http://www.cs.virginia.edu/~gfx/papers/pdfs/59_HowThingsWork.pdf}

\url{https://smartsite.ucdavis.edu/access/content/group/f376a431-7205-4af5-8cb0-b706f206a07b/lectures/intro.pdf}

\url{https://smartsite.ucdavis.edu/access/content/group/f376a431-7205-4af5-8cb0-b706f206a07b/lectures/OpenGL.pdf}


\end{document}
